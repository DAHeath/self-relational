\documentclass[p.tex]{subfiles}
\begin{document}
\section{Technical Approach}\label{sec:approach}
\subsection{Products of Commands}\label{sec:product-com}
In order to expand the expressive power of our proof system, we extend
$\com$ with an additional construction: Product commands.
\[ \com ::= \cdots~|~\cprod{\com}{\com} \]
Informally,
a product command represents two commands whose executions act on
different program states. However, by considering them together we can
establish relationships between different programs or even different
parts of the same program.

To give semantic meaning to this new construction, we extend the
definition of the space of program states:
\[\state ::= \var \rightarrow \mathbb{Z}~|~\sprod{\state}{\state}\]
As in \cref{sec:language}, a state contains mappings from variables to integer
values. However, this new definition extends allows multiple
`parallel' states which we can consider simultaneously. The semantics
defined previously remain identical, but the originally defined
commands only make progress when the state is a singleton map. The new
parallel construction allows us to define sensible formal semantics for
product commands:
\begin{align*}
  \inference[\textsc{E-Prod}]{%
    \ceval{c_0}{\sigma_0}{\sigma_0'}&
    \ceval{c_1}{\sigma_1}{\sigma_1'}&
  }{%
    \ceval{\cprod{c_0}{c_1}}{\sprod{\sigma_0}{\sigma_1}}{\sprod{\sigma_0'}{\sigma_1'}}
  }
\end{align*}
That is, two parallel commands executed over two parallel states
execute independently.

TODO

\subsection{A Self-Relational Proof System}
\begin{figure}
\begin{spreadlines}{5pt}
\begin{subequations}
\begin{gather*}
  \inference[\textsc{Assign}]{%
  }{%
    \hoare{\subst{x}{a}{P}}{\cassign{x}{a}}{P}
  }
  \qquad
  \inference[\textsc{Skip}]{%
  }{%
    \hoare{P}{\cskip}{P}
  }
  \qquad
  \inference[\textsc{Cons}]{%
    P \Rightarrow P'&
    \hoare{P'}{c}{Q'}&
    Q' \Rightarrow Q
  }{%
    \hoare{P}{c}{Q}
  }
  \\
  \inference[\textsc{Sum}]{%
    \hoare{P}{c_0}{Q}&
    \hoare{P}{c_1}{Q}
  }{%
    \hoare{P}{\csum{c_0}{c_1}}{Q}
  }
  \qquad
  \inference[\textsc{Assert}]{%
  }{%
    \hoare{P}{\cassert{b}}{P \land b}
  }
  \qquad
  \inference[\textsc{Loop}]{%
    \hoare{P}{c}{P}
  }{%
    \hoare{P}{\cloop{c}}{P}
  }
  \end{gather*}
  \begin{empheq}[box=\fbox]{gather*}
  \inference[\textsc{Iso}]{%
    c_0 \cong c_1&
    \hoare{P}{c_1}{Q}
  }{%
    \hoare{P}{c_0}{Q}
  }
  \qquad
  \inference[\textsc{Seq}]{%
    \forall \sigma_0.\hoare{P}{c_0}{\aleft(R, \sigma_0)}&
    \forall \sigma_1.\hoare{\aright(S, \sigma_1)}{c_1}{Q}\\
    \hoare{R}{c_0 \times c_1}{S}
  }{%
    \hoare{P}{\cseq{c_0}{c_1}}{Q}
  }
  \\
  \inference[\textsc{Prod}]{%
    \forall \sigma_1.\hoare{\aright(P, \sigma_1)}{c_0}{\aright(R, \sigma_1)}\\
    \forall \sigma_0.\hoare{\aleft(R, \sigma_0)}{c_1}{\aleft(Q, \sigma_0)}
  }{%
    \hoare{P}{c_0 \times c_1}{Q}
  }
  \qquad
  \inference[\textsc{Split}]{%
    \hoare{P_0}{c_0}{Q_0}&
    P\, \Rightarrow \pairwise(P_{\,0}, P_{\,1})\\
    \hoare{P_1}{c_1}{Q_1}&
    Q \Leftarrow \pairwise(Q_0,Q_1)
  }{%
    \hoare{P}{c_0 \times c_1}{Q}
  }
  \\
  \inference[\textsc{Comm}]{%
    \hoare{\commute~P}{c_1 \times c_0}{\commute~Q}
  }{%
    \hoare{P}{c_0 \times c_1}{Q}
  }
  \qquad
  \inference[\textsc{Assoc}]{%
    \hoare{\associate~P}{(c_0 \times c_1) \times c_2}{\associate~Q}
  }{%
    \hoare{P}{c_0 \times (c_1 \times c_2)}{Q}
  }
  \end{empheq}
  \begin{gather*}
  \aleft(P, \sigma_0) := \lambda\sigma_1.~P(\sigma_0 \otimes \sigma_1)
  \qquad
  \aright(P, \sigma_1) := \lambda\sigma_0.~P(\sigma_0 \otimes \sigma_1)
  \\
  \commute(P) := \lambda(\sigma_0 \otimes \sigma_1).~P(\sigma_1 \otimes \sigma_0)
  \qquad
  \associate(P) :=%
  \lambda((\sigma_0 \otimes \sigma_1) \otimes \sigma_2).~P(\sigma_0
  \otimes (\sigma_1 \otimes \sigma_2))\\
  \pairwise(P, Q) := \lambda(\sprod{\sigma_0}{\sigma_1}).~P(\sigma_0) \land Q(\sigma_1)
\end{gather*}
\end{subequations}
\end{spreadlines}
\caption{The self-relational proof system. Judgements are over
Hoare Triples. Key rules that deviate from more traditional Hoare
Logic systems are boxed.
$\textsf{commute}$, $\textsf{associate}$, and
$\textsf{pairwise}$ are helper definitions for the proof rules.
Metavariables $P, Q, R\ldots$ represent program
assertions. Other metavariables are consistent with
\cref{fig:semantics}}\label{fig:proof-system}
\end{figure}

\subsection{Command Isomorphisms}

\begin{figure}
\begin{spreadlines}{5pt}
\begin{gather*}
  \inference[$\textsc{I-Skip}_L$]{%
  }{%
    \cseq{\cskip}{c} \cong c
  }
  \qquad
  \inference[$\textsc{I-Skip}_R$]{%
  }{%
    \cseq{c}{\cskip} \cong c
  }
  \\
  \inference[\textsc{I-SeqProd}]{%
  }{%
    \cprod{(\cseq{c_0}{c_1})}{(\cseq{c_2}{c_3})} \cong
    \cseq{(\cprod{c_0}{c_2})}{(\cprod{c_1}{c_3})}
  }
  \qquad
  \inference[\textsc{I-Unroll}]{%
  }{%
    \cloop{c} \cong \cloop{\cseq{c}{(\csum{c}{\cskip})}}
  }
  \inference[\textsc{I-SumProd}]{%
  }{%
    \cprod{(\csum{c_0}{c_1})}{c_2} \cong
    \csum{(\cprod{c_0}{c_2})}{(\cprod{c_1}{c_2})}
  }
\end{gather*}
\end{spreadlines}
\caption{%
  Program isomorphisms that are useful in conjunction with the
  self-relational proof system. Metavariables are consistent with
  \cref{fig:semantics}.
}
\end{figure}

\end{document}
